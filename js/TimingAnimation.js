// Generated by CoffeeScript 1.12.4
var Animation, Easing, LazyVar, Timer, Type, type;

Animation = require("Animated").Animation;

LazyVar = require("LazyVar");

Easing = require("easing");

Timer = require("timer");

Type = require("Type");

type = Type("TimingAnimation");

type.inherits(Animation);

type.defineArgs(function() {
  return {
    required: true,
    types: {
      toValue: Number,
      duration: Number,
      easing: Function,
      delay: Number
    },
    defaults: {
      easing: Easing.linear,
      delay: 0
    }
  };
});

type.defineFrozenValues(function(options) {
  return {
    toValue: options.toValue,
    duration: options.duration,
    easing: options.easing,
    delay: options.delay,
    _velocity: !options.useNativeDriver ? this._initVelocity() : void 0
  };
});

type.defineValues({
  _time: null,
  _value: null,
  _progress: 0,
  _lastTime: null,
  _lastValue: null,
  _delayTimer: null
});

type.defineGetters({
  time: function() {
    if (this._useNativeDriver) {
      return this._computeTime();
    } else {
      return this._time;
    }
  },
  value: function() {
    if (this._useNativeDriver) {
      return this._valueAtProgress(this.easing(this._computeTime() / this.duration));
    } else {
      return this._value;
    }
  },
  progress: function() {
    if (this._useNativeDriver) {
      return this.easing(this._computeTime() / this.duration);
    } else {
      return this._progress;
    }
  },
  velocity: function() {
    if (this._useNativeDriver) {
      return log.warn("Cannot access 'velocity' for native animations!");
    } else {
      return this._velocity.get();
    }
  }
});

type.defineMethods({
  _initVelocity: function() {
    return LazyVar((function(_this) {
      return function() {
        return (_this._value - _this._lastValue) / (_this._time - _this._lastTime);
      };
    })(this));
  },
  _computeTime: function() {
    return Math.min(this.duration, Date.now() - this.startTime);
  },
  _valueAtProgress: function(progress) {
    return this.fromValue + progress * (this.toValue - this.fromValue);
  }
});

type.overrideMethods({
  _startAnimation: function(animated) {
    if (this.delay === 0) {
      return this.__super(arguments);
    } else if (this._delayTimer) {
      this._delayTimer = null;
      return this.__super(arguments);
    } else {
      return this._delayTimer = Timer(this.delay, (function(_this) {
        return function() {
          return _this._startAnimation(animated);
        };
      })(this));
    }
  },
  __onAnimationStart: function() {
    this._time = this.startTime;
    this._value = this.fromValue;
    if (this.duration > 0) {
      return this.__super(arguments);
    } else {
      return this._requestAnimationFrame((function(_this) {
        return function() {
          _this._animationFrame = null;
          _this._onUpdate(_this._valueAtProgress(1));
          return _this.stop(true);
        };
      })(this));
    }
  },
  __computeValue: function() {
    this._lastTime = this._time;
    this._lastValue = this._value;
    this._velocity.reset();
    this._time = this._computeTime();
    this._progress = this.easing(this._time / this.duration);
    return this._value = this._valueAtProgress(this._progress);
  },
  __onAnimationUpdate: function(value) {
    if (this._time === this.duration) {
      return this.stop(true);
    }
  },
  __onAnimationEnd: function() {
    if (!this._delayTimer) {
      return;
    }
    this._delayTimer.prevent();
    return this._delayTimer = null;
  },
  __captureFrame: function() {
    return {
      time: this._time,
      value: this._value,
      progress: this._progress
    };
  },
  __getNativeConfig: function() {
    var frameDuration, frameTime, frames;
    frames = [];
    frameDuration = 1000 / 60;
    frameTime = 0;
    while (frameTime < this.duration) {
      frames.push(this.easing(frameTime / this.duration));
      frameTime += frameDuration;
    }
    if (frameTime - this.duration < 0.001) {
      frames.push(this.easing(1));
    }
    return {
      type: "frames",
      frames: frames,
      toValue: this.toValue
    };
  }
});

module.exports = type.build();
