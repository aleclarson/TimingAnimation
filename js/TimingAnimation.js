// Generated by CoffeeScript 1.12.4
var Animation, Timer, Type, mutable, type;

Animation = require("Animated").Animation;

mutable = require("Property").mutable;

Timer = require("timer");

Type = require("Type");

type = Type("TimingAnimation");

type.inherits(Animation);

type.defineArgs(function() {
  return {
    required: {
      toValue: true,
      duration: true
    },
    types: {
      toValue: Number,
      duration: Number,
      easing: Function,
      delay: Number
    }
  };
});

type.defineFrozenValues(function(options) {
  return {
    toValue: options.toValue,
    duration: options.duration,
    easing: options.easing,
    delay: options.delay
  };
});

type.defineValues({
  _delayTimer: null
});

type.defineGetters({
  value: function() {
    return this._valueAtProgress(this.progress);
  },
  elapsedTime: function() {
    return Date.now() - this.startTime;
  },
  progress: function() {
    var progress;
    progress = Math.min(1, this.elapsedTime / this.duration);
    if (this.easing) {
      return this.easing(progress);
    }
    return progress;
  }
});

type.defineMethods({
  _valueAtProgress: function(progress) {
    return this.fromValue + progress * (this.toValue - this.fromValue);
  }
});

type.overrideMethods({
  _startAnimation: function(animated) {
    if (!this._useNativeDriver) {
      mutable.define(this, "value", {
        value: this.fromValue
      });
      mutable.define(this, "progress", {
        value: 0
      });
    }
    if (!this.delay) {
      return this.__super(arguments);
    }
    if (this._delayTimer) {
      this._delayTimer = null;
      return this.__super(arguments);
    }
    this._delayTimer = Timer(this.delay, (function(_this) {
      return function() {
        return _this._startAnimation(animated);
      };
    })(this));
  },
  __onAnimationStart: function() {
    if (this.duration > 0) {
      return this.__super(arguments);
    }
    return this._requestAnimationFrame((function(_this) {
      return function() {
        _this._animationFrame = null;
        _this._onUpdate(_this._valueAtProgress(1));
        _this.stop(true);
      };
    })(this));
  },
  __computeValue: function() {
    var progress;
    progress = Math.min(1, this.elapsedTime / this.duration);
    if (this.easing) {
      progress = this.easing(progress);
    }
    this.value = this._valueAtProgress(progress);
    this.progress = progress;
    return this.value;
  },
  __onAnimationUpdate: function(value) {
    if (value === this.toValue) {
      this._onUpdate(value);
      this.stop(true);
    }
  },
  __onAnimationEnd: function(finished) {
    if (this._delayTimer) {
      this._delayTimer.prevent();
      this._delayTimer = null;
    }
  },
  __getNativeConfig: function() {
    var frameDuration, frameTime, frames;
    frames = [];
    frameDuration = 1000 / 60;
    frameTime = 0;
    while (frameTime < this.duration) {
      frames.push(this.easing(frameTime / this.duration));
      frameTime += frameDuration;
    }
    if (frameTime - this.duration < 0.001) {
      frames.push(this.easing(1));
    }
    return {
      type: "frames",
      frames: frames,
      toValue: this.toValue
    };
  }
});

module.exports = type.build();
